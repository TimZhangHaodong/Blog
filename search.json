[{"title":"下载协议鉴赏","date":"2023-08-03T13:41:38.000Z","url":"/blog/2023/08/03/%E4%B8%8B%E8%BD%BD%E5%8D%8F%E8%AE%AE%E9%89%B4%E8%B5%8F/","tags":[["ETC","/blog/tags/ETC/"]],"categories":[["DIYnas","/blog/categories/DIYnas/"]],"content":"品名：网络存储下载协议ed2k ed2k是电驴(eDonkey)网络的协议之一。电驴网络是一个用于文件共享的点对点(P2P)网络，早期非常流行的文件共享网络之一。该网络允许用户通过ed2k协议来分享和下载文件。 电驴网络的工作原理是：用户共享自己的文件，并通过服务器来广播文件信息，其他用户可以搜索到这些文件并进行下载。ed2k链接是用于标识特定文件的链接格式，它包含了文件的名称、大小、哈希值等信息，使其他用户能够准确找到并下载该文件。 然而，由于版权问题和其他技术的出现，电驴网络的流行度在近年来逐渐减少。现在更多的人倾向于使用其他文件共享协议或在线服务来获取和分享文件。 http(s) HTTP和HTTPS是用于在网络上传输数据的协议，它们通常用于浏览器与服务器之间的通信。虽然它们主要用于浏览网页，但也可以用于下载文件。 HTTP (HyperText Transfer Protocol) 是一种用于传输超文本的协议，它是Web浏览器和Web服务器之间最常用的通信协议。当你在浏览器中输入一个网址并按下回车键时，浏览器会向服务器发送HTTP请求，并在服务器响应时接收HTTP响应，这样你就能在浏览器上看到网页内容。 HTTPS (HyperText Transfer Protocol Secure) 则是HTTP的加密版本。HTTPS在数据传输过程中使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议进行加密，确保数据在传输过程中是安全的。它在安全性方面比HTTP更优，因此对于涉及敏感信息（如密码、信用卡号等）的网页，或者需要保护数据传输安全性的情况下，都使用HTTPS。 虽然HTTP和HTTPS主要用于浏览网页，但它们也可以用于文件下载。通常，通过在浏览器中访问一个包含文件链接的HTTP或HTTPS网页，你可以点击链接进行文件下载。此外，还有一些下载管理器或下载工具可以使用HTTP或HTTPS协议来下载文件。 ftp FTP (File Transfer Protocol) 是一种用于在计算机网络上进行文件传输的协议。它是Internet上最早的文件传输协议之一，允许用户在客户端和服务器之间传输文件。FTP被广泛用于从服务器下载文件或将文件上传到服务器。 FTP的工作方式是，用户在FTP客户端上输入FTP服务器的地址、用户名和密码来进行连接。一旦建立了连接，用户可以浏览服务器上的文件和目录结构，选择要下载或上传的文件，并在客户端和服务器之间进行文件传输。 FTP协议支持两种传输模式： 主动模式（Active Mode）：在主动模式中，FTP客户端随机选择一个端口号并通知服务器，然后服务器在该端口上建立数据连接用于文件传输。 被动模式（Passive Mode）：在被动模式中，FTP客户端向服务器请求一个随机端口用于数据传输，而服务器在该端口上等待客户端的连接。 虽然FTP在过去非常流行，但随着时间的推移，出于安全性方面的考虑，越来越多的网站和服务已经转向使用更加安全的协议，如SFTP (Secure File Transfer Protocol) 或 FTPS (FTP Secure)。SFTP和FTPS都基于SSH (Secure Shell) 和SSL&#x2F;TLS (Secure Sockets Layer&#x2F;Transport Layer Security)协议，提供了更高的数据传输安全性。 thunder “Thunder” 是迅雷下载软件的中文名。迅雷是一款非常著名的下载工具，特别受到中国用户的喜爱。 迅雷并不使用独立的下载协议，而是基于HTTP、FTP等常见的下载协议进行文件下载。迅雷通过优化下载算法和多线程技术，能够加快文件下载速度，并且支持断点续传功能，使得下载过程更加稳定和高效。 除了常规的HTTP和FTP下载，迅雷还提供了一种名为”迅雷链”（或称”thunder:&#x2F;&#x2F;“）的下载链接，它是一种自定义的链接格式，可以通过迅雷软件直接打开并开始下载对应的文件。”迅雷链”以”thunder:&#x2F;&#x2F;“开头，后面跟着一串经过编码的信息，用于识别下载链接和一些附加信息。 需要注意的是，迅雷软件曾经因为广告、捆绑软件等一些用户体验和隐私问题而备受争议。用户在使用下载工具时应该注意下载来源和软件的合法性，并避免下载未经授权的版权受保护内容。 "},{"title":"cache","date":"2023-06-06T03:46:13.000Z","url":"/blog/2023/06/06/cache/","tags":[["C++","/blog/tags/C/"]],"categories":[["SearchEngine","/blog/categories/SearchEngine/"]],"content":" 缓存结构一级缓存，搜索结果型（粒度较大，响应速度快）； 先从缓存中找 倒排列表型（粒度小，响应慢）； 这种情况下，会先分析，再走缓存。 二级缓存，融合上述两种。 缓存的评价命中率在搜索日志中统计缓存的命中，由此来定义缓存淘汰的策略，如果命中率较高，应设为较高的优先级 淘汰策略 动态策略 大体上来说：ＬＲＵ；ｓｉｚｅ－ａｄｊｕｓｔｅｄＬＲＵ 以及Ｌａｎｄｌｏｒｄ 这里以LRU为例 可以用计数器来淘汰，当命中一个缓存的时候，将它的计数器置为0，没有命中的缓存加1，当缓存满的时候，将这个计数器最大的淘汰。 如果有多个缓存的计数器相等，该怎么办？ 1.全剔除 2.剔除最老的 3.剔除命中率最低的 此外还有动态静态混合策略。"},{"title":"search_engine","date":"2023-06-02T12:40:34.000Z","url":"/blog/2023/06/02/search-engine/","tags":[["C++","/blog/tags/C/"]],"categories":[["项目实战","/blog/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"]],"content":" 2023年6月2日 20:41:34 今天先搞思路： 离线部分：字典库，索引库。中文，英文（空格）的分词方式不同，中文采用一个分词的第三方库（结巴）。 最后生成四个文件，用于关键字推荐。 这是一个独立程序，用法：将语料输入，输出字典库（单词+词频）"},{"title":"面试八股00","date":"2023-05-23T11:22:41.000Z","url":"/blog/2023/05/23/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A100/","tags":[["ETC","/blog/tags/ETC/"]],"categories":[["网络编程","/blog/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"]],"content":" TCP链接建立的过程需要三次握手，为什么？ 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认 Why do we need a 3-way handshake? Why not just 2-way TCP链接断开的过程需要四次挥手，为什么？ 因为不像建立连接的过程，接收方收到连接请求后可以立即发送SYN进行连接，释放资源时，接受方在收到发送方的释放连接请求后，还需要一段时间来处理未完成的发送请求，这里需要两次确认发送方的请求：第一次是未处理完，我还不能释放，但是收到了你的请求，告诉发送方一声，等等我；第二次确认表示已经处理完请求了，我也可以进行释放了。 因此需要四次 本质原因是网络是不可靠的 关闭链接时,服务器端可不可以主动断开链接?为什么？ 当服务器进程被终止时，会关闭其打开的所有文件描述符，此时就会向客户端发送一个FIN 的报文,客户端则响应一个ACK 报文,但是这样只完成了“四次挥手”的前两次挥手，也就是说这样只实现了半关闭，客户端仍然可以向服务器写入数据。 但是当客户端向服务器写入数据时，由于服务器端的套接字进程已经终止，此时连接的状态已经异常了，所以服务端进程不会向客户端发送ACK 报文，而是发送了一个RST 报文请求将处于异常状态的连接复位； 如果客户端此时还要向服务端发送数据，将诱发服务端TCP向服务端发送SIGPIPE信号，SIGPIPE信号的默认处理是终止程序，导致客户端进程退出。 为什么需要TIME_WAIT状态，该状态可以删除吗？ IME_WAIT状态就是用来重发可能丢失的ACK报文 。 如果发送方的最后一次ack没有被接收方收到的话，那么接收方会进行重传第三次的释放连接请求，TIME_WAIT就是为了在这种情况下重发丢失了的ack报文。 TCP协议和UDP协议有啥区别？ 连接性 可靠性 报文首部 流 吞吐量控制 双工性 TCP是面向连接的协议，在收发数据前必须和对方建立可靠的连接，建立连接的3次握手、断开连接的4次挥手，为数据传输打下可靠基础; TCP提供可靠交付的服务，传输过程中采用许多方法保证在连接上提供可靠的传输服务，如编号与确认、流量控制、计时器等，确保数据无差错，不丢失，不重复且按序到达; TCP报文首部有20个字节，额外开销大; TCP协议面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配; TCP拥塞控制、流量控制、重传机制、滑动窗口等机制保证传输质量; TCP只能点对点全双工通信; UDP是一个面向无连接的协议，数据传输前，源端和终端不建立连接，发送端尽可能快的将数据扔到网络上，接收端从消息队列中读取消息段。 UDP使用尽可能最大努力交付，但不保证可靠交付。 UDP报文首部只有8个字节，标题短，开销小。 UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用。 UDP没有。 UDP支持一对一、一对多、多对一和多对多的交互通信。 网络IO复用模型有哪些？它们之间的异同是什么？ 阻塞式IO，非阻塞式IO，IO复用，信号驱动式IO，异步IO 前四种都是同步的，而异步IO是异步的； 第一阶段（等待数据）： 第二阶段（从内核空间拷贝数据到用户内存空间）：前四种同步的IO都会在此阻塞， 网络IO模型有哪些？ 什么是同步、异步？什么是阻塞、非阻塞？ Reactor模型 vs Proactor模型对比，各自的特点是？ 什么是大端模式，什么是小端模式？大端模式和小端模式有什么区别？ TCP协议的服务器和客户端的基本通信流程是怎样的？其中有哪些函数是阻塞的？ listen函数的第二个参数具有什么样的作用？其背后的原理是什么？ "},{"title":"keep alive","date":"2023-05-23T10:42:40.000Z","url":"/blog/2023/05/23/keep-alive/","tags":[["计算机网络","/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["TCP/HTTP","/blog/categories/TCP-HTTP/"]],"content":" 长时间不通讯，TCP会保持连接吗？如何得知对方还活着？如何得知这个TCP连接是健康且具有通讯能力的？ TCP的保活机制 keepalive系统级的 保活机制默认是关闭的，TCP连接的任何一方都可打开此功能。 有三个主要配置参数用来控制保活功能保活时间tcp_keepalive_time、 探测时间间隔tcp_keepalive_intvl、 探测循环次数tcp_keepalive_probes。 保活时间（tcp_keepalive_time）默认7200秒， 保活时间间隔（tcp_keepalive_intvl）默认75秒， 探测循环次数（tcp_keepalive_probes）默认9次默认情况下一条TCP连接在2小时（7200秒）都没有报文交换后，会开始进行保活探测，若再经过9*75秒&#x3D;11分钟15秒的循环探测都未收到探测响应， 即共计：2小时11分钟15秒后会自动断开TCP连接。 单条socket是由 TCP 层（内核态） 实现的： 保活时间TCP_KEEPIDLE、 保活探测时间间隔TCP_KEEPINTVL、 探测循环次数TCP_KEEPCNT 如果在一段时间（保活时间：tcp_keepalive_time）内此连接都不活跃，开启保活功能的一端会向对端发送一个保活探测报文 若对端正常存活，且连接有效，对端必然能收到探测报文并进行响应。此时，发送端收到响应报文则证明TCP连接正常，重置保活时间计数器即可在探测过程中，对端主机会处于以下四种状态之一： 状态 处理 对方主机仍在工作，并且可达 TCP连接正常，将保活计时器重置 对方主机已崩溃、已关闭或正在重启 TCP连接不正常，经过指定次数的探测依然没得到响应，则断开连接 对方主机崩溃且已重启 重启后原连接已失效，对方由于不认识探测报文，会响应重置报文段，请求段将连接断开 对方主机仍在工作，但由于网络原因不可达 TCP连接不正常，经过指定次数的探测依然没得到响应，则断开连接 由此可见当对方主机网络等等出现故障的时候，都会断开连接 HTTP由应用层实现http1.0默认是关闭的，通过http请求头设置“connection: keep-alive”进行开启； http1.1中默认开启，通过http请求头设置“connection: close”关闭在一次http请求中，服务器进行响应后，不再直接断开TCP连接，而是将TCP连接维持一段时间。 在这段时间内，如果同一客户端再次向服务端发起http请求，便可以复用此TCP连接，向服务端发起请求，并重置timeout时间计数器，在接下来一段时间内还可以继续复用 优点：1、keep-alive机制避免了频繁建立和销毁连接的开销。 2、减少服务端TIME_WAIT状态的TCP连接的数量 总结发送方式：tcp具备双端连续收发报文的能力，开启了keep-alive的HTTP连接，由于协议本身的限制，服务端无法主动发起应用报文。TCP中的keepalive是用来保鲜、保活的； HTTP中的keep-alive机制主要为了让支撑它的TCP连接活的的更久， 所以通常又叫做：HTTP persistent connection（持久连接） 和 HTTP connection reuse（连接重用） 原文链接： "},{"title":"一道来自过去的数学题","date":"2023-05-21T06:48:40.000Z","url":"/blog/2023/05/21/%E4%B8%80%E9%81%93%E6%9D%A5%E8%87%AA%E8%BF%87%E5%8E%BB%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/","tags":[["ETC","/blog/tags/ETC/"]],"categories":[["算着玩的","/blog/categories/%E7%AE%97%E7%9D%80%E7%8E%A9%E7%9A%84/"]],"content":"记忆里有味道的风景最近被问到了一道初中选拔考试的数学题目，我一看挺眼熟的，我当年的选拔考试也见过，哈哈，这么多年了还是没啥创意啊~ 我这里就口述一下吧，懒得找原题了 说啊，有四只猴子拿了一堆桃子，猴1呢把这些桃子均分成四份，然后余一个自己吃了，然后再取走其中的一份，猴2、猴3、猴4都是如此，问：这堆桃子最初至少有几个？ 啊哈，本人当年是怎么做的呢（当然，我一开始也是这么想的，哈哈） 老办法设最后桃子x个或者最初桃子有x个，我呢是设最后有x个（栈思想雏形？哈哈） 然后每次都是递归地乘个三分之四，再加一；这样做四次，得到一个关于x的分式，然后凑整。。。 解出来是253 显然这不是咱们今天的主题 与进制的联想怎么想到的呢？一看见253这个数字就来反应了（数字敏感肌？），盲猜一手四的四次方减三，减三是以四为模的加一的补数（有问题请参看《计算机组成原理》，嘿嘿） ok，有了这些想法，咱们就可以稍微验证一下了，果不其然啊如果是三个猴子分（猴4不操作），桃子最少就是61个，俩猴（猴3、猴4不操作）就是13个桃子，于是咱们稍微推广一下哎 n个猴子（花果山？哈哈）在一条流水线上干活，这时候传过来了一堆桃子，猴1（大概是悟空），身手敏捷加火眼金睛，迅速分完四堆吃了剩下的那一个桃子，然后拿走了一堆取经去了~，猴2（也许是悟饭）学他老爸。。。就这样最后一只猴n（动物园的）也这么搞了，当然了，最后它也留下了三等份的桃子。 请问流水线上传了多少桃子？ 显然答案应该是4n -3，再稍微推广一下 分a堆后，每次都余b个，然后c个猴子，当然a肯定大于b, 问：至少有多少个桃子？ 这个我就不去证明了，留一个猜想吧：ac -a+b 回过头来，咱们看看这个进制哈，我现在呢搞一个四进制出来，显然啊，这个桃子总数代表的四进制，最低位必然是1，那么其它的几位呢？我们把操作过程化一下： 如果您有困惑，请及时查阅《计算机组成原理》 第一步：total减一，得到result1 第二步：result1除以四（也就是右移一位)，得到result2 第三步：result3乘以三，得到result4, 第四步：回到第一步，开始循环。。。 显然循环的次数就是猴子分桃子的次数。现在我们就可以知道了**剩下的几位必定都是3，而3的数量取决于你的猴子分桃子的次数**，比如原题是4个猴，那么我直接可以得到答案：0003 3331，转换成十进制就是253 :sunglasses: 上面那个结论怎么得来的呢？ 进制的乘法 小时候我学习乘法的时候，老师要求背九九乘法口诀，事实上也没啥难度~ 但如果你学习了二进制，你只要知道一一得一，零零得零，零一得零就好了，哈哈 ^^_ 这里就不得不说一下进制的乘法了，我们所学习的打竖式的计算方法，实际上是做了一些部分积 ，在所有的进制中都可以这么做，在我归纳出的操作步骤中第三步进行了乘以3的操作，这里有个关键点就是进入第四步开始循环前，result4的最低位必须是1。 那么这个1怎么来的呢？ 有1吗？不同于复杂的十进制:-) ,三七二十一，在四进制是三三得二一，也就是0021 是的，也正因为如此，我们需要在每一次循环前准备一个3 离开有你的季节好了，至此咱们稍微告一段落，也不再做深入的研究了。 这道题目勾起了我的回忆，那个时候我每周都要做一个小时的公交车去补习班，在那里遇到了很多个性鲜明的同学，最主要的是两位恩师，以往在学校中倍感压抑，对学校的主课老师真是没有一点认可。 而这两位恩师，亦师亦友，带我走出了那口狭小的水井。"},{"title":"初窥策略模式","date":"2023-05-20T13:58:58.000Z","url":"/blog/2023/05/20/%E5%88%9D%E7%AA%A5%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","tags":[["DP","/blog/tags/DP/"]],"categories":[["Strategy","/blog/categories/Strategy/"]],"content":"这篇博客就当作是设计模式学习的开篇之作，目前手头上的资料是大话，重构和GOF的DP 目标境界：无剑胜有剑！ 策略模式用来封装算法，在实践中，可以用来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式。 当不同的行为堆砌在一个类中，很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句 "},{"title":"OO真经","date":"2023-05-18T12:36:54.000Z","url":"/blog/2023/05/18/OO%E7%9C%9F%E7%BB%8F/","tags":[["READINGS","/blog/tags/READINGS/"]],"categories":[["面向对象","/blog/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"]],"content":" 看了OO真经，真有意思，而且感触颇多。 附一下链接： OO真经——关于面向对象的哲学体系及科学体系的探讨（中） - T2噬菌体 - 博客园 (cnblogs.com) 哈哈，先来几个“暴论”：先有儿子后有爹（这个我还挺认可的，儿子没生出来，你做谁爹去？当然你可以跟我杠一下，这个爹不能搞二胎吗？那你这么想，你这二胎的爹是不是在这个二胎出来前，没法做？）； 有奶就是娘 不以其他对象实体本身为交互准则，而以其他对象的行为作为交互准则，与一个对象是否进行交互纯粹是从其行为判断，而不对对象本体有任何概念 勿忘初心！ 任何东西用得好不好，不在于是不是熟练掌握用法，而在于是不是用对了地方。而要想用对地方，就要弄清楚这个东西的“怎么出来的”和“出来是做什么用的”。 世界树 The world tree is represented as a colossal tree which supports the heavens, thereby connecting the heavens, the terrestrial world, and, through its roots, the underworld. 世界树世界树，世界本身就是一棵树！ 在现实世界中是只有对象的，这里借用一下面向对象的世界观，这个世界的运作，在某个初始作用力下，对象间的交互完成了这个世界 ,我们从所有的对象可以不断进行抽象，乃至到了更高层的时候，这个世界的就剩下了物质和意识。"},{"title":"STL-alloc","date":"2023-05-16T13:15:11.000Z","url":"/blog/2023/05/16/STL-alloc/","tags":[["C++","/blog/tags/C/"]],"categories":[["深入源码","/blog/categories/%E6%B7%B1%E5%85%A5%E6%BA%90%E7%A0%81/"]],"content":" 这里咱们就看allocate :cloud_with_rain: SGI的设计哲学 申请堆空间 考虑多线程 考虑内存不足时的应变措施 考虑过多“小型区块”可能造成的内存碎片问题 走进源码众所周知，第一级空间配置器使用类模板malloc_alloc_template ,其底层使用的是malloc&#x2F;free， 而二级空间配置器使用类模板，default_alloc_template,其底层根据申请的空间大小有不同的策略。 一般默认的配置器就是二级空间配置器，再来说说这个第二级配置器的策略，当配置区块超过128字节，他就被视作足够大，这个时候就会调用一级配置器，那么不超过128字节的时候呢，就是足够小，为了降低额外负担（每个申请的内存都会有给系统用的cookie），或者说是降低占比，于是采用复杂的内存池（ memory pool ）： 内存池 此法又称作 sub-allocation ，每次配置了一大块内存，并维护一个与之对应的自由链表，下次如果有相同大小的内存需求，就直接从自由链表中取出。如果客端释还这些小额的区块，配置器会进行回收到自由链表。 二级配置器大致逻辑是这样的：先判断区块大小，大于128字节，就调用一级配置器去；else，就要去检查对应的自由链表。 如果自由链表之内有可用的区块，就直接拿来用，如果没有可用的区块，就将区块大小上调至8的整数倍的边界，然后调用 refill(),为自由链表重新填充空间。 这里咱们暂且屏蔽多线程的情况，源码本人已修改方便阅读 补充一下 refill _S_chunk_alloc "},{"title":"迭代器失效问题","date":"2023-05-15T11:26:07.000Z","url":"/blog/2023/05/15/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/","tags":[["C++","/blog/tags/C/"]],"categories":[["STL入门","/blog/categories/STL%E5%85%A5%E9%97%A8/"]],"content":" 有时候我们用vector进行insert，会得到意想不到的结果，其实是因为迭代器失效了 迭代器失效是如何产生的？ 比方说对一个vector容器进行一个insert的操作，那么这个时候可能容器已经完成了扩容的操作，所以我之前定位的迭代器访问的就是未知区域。 当然了，deque也会发生扩容的操作，所以他也有可能会发生迭代器失效 如何避免？在使用迭代器的时候，都先把迭代器重新定位，让他跟新的空间产生联系，这样无论底层是否发生了扩容，迭代器的位置都不是绝对的了。"},{"title":"STL-自定义类操作","date":"2023-05-15T06:17:17.000Z","url":"/blog/2023/05/15/STL-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E6%93%8D%E4%BD%9C/","tags":[["C++","/blog/tags/C/"]],"categories":[["STL入门","/blog/categories/STL%E5%85%A5%E9%97%A8/"]],"content":" 自定义的类型在关联式容器中，通常需要重写Compare，如果是在无序的关联式容器，则可能要写哈希函数和判等（equal_to） 关联式容器一般说来，排序方式是升序的,当然，升序也是很好写的 :smile: ,对应的就是 std::greater class Compare &#x3D; std::less 先来一个自定义类型 *比较的逻辑可以自由发挥，如果想比较两点间的距离，可以用 hypot，他在&lt;math.h&gt;* 俺就简单写一下哈，优先比较横坐标，其次比较纵坐标 重写小于（大于）运算符这个方案的思路来自于编译时报错，编译器提示没有重载运算符 当然了，为了访问坐标，需要建立友谊:fried_shrimp: 在类的内部把这个函数声明为友元函数 模板的特化（全特化）这个方案的也容易想到，毕竟命名空间是可以扩展的，这里比较逻辑我就不再赘述了 上面这两个的用法挺轻松的，因为用的还是默认的Compare， 而函数对象，在你定义一个容器的时候，需要把他加上 函数对象定制一个比较函数罢了 :sunglasses: 诶嘿，这里就不硬件伏笔了 :black_joker: 无序式关联式容器无序式的关联式容器底层是哈希，各个操作的时间复杂度是常数级的，比对数级的关联式容器快多了，如果有顺序要求，当我没说 :joy: class Hash &#x3D; std::hash, class KeyEqual &#x3D; std::equal_to, 哈希no重写由于本人目前水平有限，哈希函数就不写出来献丑了，ref一个： std::equal_to 重写包括三种形式：将std::equal_to进行模板的特化、重载等号运算符、自定义函数对象。 懒得写了，就酱~ ps：如果两者关系既不大于也不小于，我觉得就是等于，当然等价的关系应当具备传递性"}]