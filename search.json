[{"title":"STL-alloc","date":"2023-05-16T13:15:11.000Z","url":"/blog/2023/05/16/STL-alloc/","tags":[["C++","/blog/tags/C/"]],"categories":[["深入源码","/blog/categories/%E6%B7%B1%E5%85%A5%E6%BA%90%E7%A0%81/"]],"content":" 这里咱们就看allocate :cloud_with_rain: SGI的设计哲学 申请堆空间 考虑多线程 考虑内存不足时的应变措施 考虑过多“小型区块”可能造成的内存碎片问题 走进源码众所周知，第一级空间配置器使用类模板malloc_alloc_template ,其底层使用的是malloc&#x2F;free， 而二级空间配置器使用类模板，default_alloc_template,其底层根据申请的空间大小有不同的策略。 一般默认的配置器就是二级空间配置器，再来说说这个第二级配置器的策略，当配置区块超过128字节，他就被视作足够大，这个时候就会调用一级配置器，那么不超过128字节的时候呢，就是足够小，为了降低额外负担（每个申请的内存都会有给系统用的cookie），或者说是降低占比，于是采用复杂的内存池（ memory pool ）： 内存池 此法又称作 sub-allocation ，每次配置了一大块内存，并维护一个与之对应的自由链表，下次如果有相同大小的内存需求，就直接从自由链表中取出。如果客端释还这些小额的区块，配置器会进行回收到自由链表。 二级配置器大致逻辑是这样的：先判断区块大小，大于128字节，就调用一级配置器去；else，就要去检查对应的自由链表。 如果自由链表之内有可用的区块，就直接拿来用，如果没有可用的区块，就将区块大小上调至8的整数倍的边界，然后调用 refill(),为自由链表重新填充空间。 这里咱们暂且屏蔽多线程的情况，源码本人已修改方便阅读 补充一下 refill _S_chunk_alloc "},{"title":"迭代器失效问题","date":"2023-05-15T11:26:07.000Z","url":"/blog/2023/05/15/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/","tags":[["C++","/blog/tags/C/"]],"categories":[["STL入门","/blog/categories/STL%E5%85%A5%E9%97%A8/"]],"content":" 有时候我们用vector进行insert，会得到意想不到的结果，其实是因为迭代器失效了 迭代器失效是如何产生的？ 比方说对一个vector容器进行一个insert的操作，那么这个时候可能容器已经完成了扩容的操作，所以我之前定位的迭代器访问的就是未知区域。 当然了，deque也会发生扩容的操作，所以他也有可能会发生迭代器失效 如何避免？在使用迭代器的时候，都先把迭代器重新定位，让他跟新的空间产生联系，这样无论底层是否发生了扩容，迭代器的位置都不是绝对的了。"},{"title":"STL-自定义类操作","date":"2023-05-15T06:17:17.000Z","url":"/blog/2023/05/15/STL-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E6%93%8D%E4%BD%9C/","tags":[["C++","/blog/tags/C/"]],"categories":[["STL入门","/blog/categories/STL%E5%85%A5%E9%97%A8/"]],"content":" 自定义的类型在关联式容器中，通常需要重写Compare，如果是在无序的关联式容器，则可能要写哈希函数和判等（equal_to） 关联式容器一般说来，排序方式是升序的,当然，升序也是很好写的 :smile: ,对应的就是 std::greater class Compare &#x3D; std::less 先来一个自定义类型 *比较的逻辑可以自由发挥，如果想比较两点间的距离，可以用 hypot，他在&lt;math.h&gt;* 俺就简单写一下哈，优先比较横坐标，其次比较纵坐标 重写小于（大于）运算符这个方案的思路来自于编译时报错，编译器提示没有重载运算符 当然了，为了访问坐标，需要建立友谊:fried_shrimp: 在类的内部把这个函数声明为友元函数 模板的特化（全特化）这个方案的也容易想到，毕竟命名空间是可以扩展的，这里比较逻辑我就不再赘述了 上面这两个的用法挺轻松的，因为用的还是默认的Compare， 而函数对象，在你定义一个容器的时候，需要把他加上 函数对象定制一个比较函数罢了 :sunglasses: 诶嘿，这里就不硬件伏笔了 :black_joker: 无序式关联式容器无序式的关联式容器底层是哈希，各个操作的时间复杂度是常数级的，比对数级的关联式容器快多了，如果有顺序要求，当我没说 :joy: class Hash &#x3D; std::hash, class KeyEqual &#x3D; std::equal_to, 哈希no重写由于本人目前水平有限，哈希函数就不写出来献丑了，ref一个： std::equal_to 重写包括三种形式：将std::equal_to进行模板的特化、重载等号运算符、自定义函数对象。 懒得写了，就酱~ ps：如果两者关系既不大于也不小于，我觉得就是等于，当然等价的关系应当具备传递性"}]